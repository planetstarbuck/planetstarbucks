{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Component, Output, ViewChild, ViewChildren, HostListener, Injectable, Directive, Input, NgModule } from '@angular/core';\nimport { isBs3, Utils } from 'ngx-bootstrap/utils';\nimport * as i1 from 'ngx-bootstrap/positioning';\nimport { PositioningService } from 'ngx-bootstrap/positioning';\nimport { Subscription, isObservable, EMPTY, from } from 'rxjs';\nimport { trigger, state, style, transition, animate } from '@angular/animations';\nimport * as i2 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport * as i3 from '@angular/forms';\nimport * as i1$1 from 'ngx-bootstrap/component-loader';\nimport { ComponentLoaderFactory } from 'ngx-bootstrap/component-loader';\nimport { debounceTime, tap, switchMap, mergeMap, filter, toArray } from 'rxjs/operators';\nconst _c0 = [\"ulElement\"];\nconst _c1 = [\"liElements\"];\n\nfunction TypeaheadContainerComponent_ng_template_0_Template(rf, ctx) {}\n\nfunction TypeaheadContainerComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 4);\n  }\n\n  if (rf & 2) {\n    const match_r7 = ctx.match;\n    const query_r8 = ctx.query;\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"innerHtml\", ctx_r2.highlight(match_r7, query_r8), i0.ɵɵsanitizeHtml);\n  }\n}\n\nfunction TypeaheadContainerComponent_ng_template_3_ng_template_2_li_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 10, 11);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const match_r11 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(match_r11);\n  }\n}\n\nfunction TypeaheadContainerComponent_ng_template_3_ng_template_2_li_1_ng_template_3_Template(rf, ctx) {}\n\nconst _c2 = function (a0, a1, a2, a3) {\n  return {\n    item: a0,\n    index: a1,\n    match: a2,\n    query: a3\n  };\n};\n\nfunction TypeaheadContainerComponent_ng_template_3_ng_template_2_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r21 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"li\", 12, 11);\n    i0.ɵɵlistener(\"mouseenter\", function TypeaheadContainerComponent_ng_template_3_ng_template_2_li_1_Template_li_mouseenter_0_listener() {\n      i0.ɵɵrestoreView(_r21);\n      const match_r11 = i0.ɵɵnextContext().$implicit;\n      const ctx_r19 = i0.ɵɵnextContext(2);\n      return ctx_r19.selectActive(match_r11);\n    });\n    i0.ɵɵelementStart(2, \"a\", 13);\n    i0.ɵɵlistener(\"click\", function TypeaheadContainerComponent_ng_template_3_ng_template_2_li_1_Template_a_click_2_listener($event) {\n      i0.ɵɵrestoreView(_r21);\n      const match_r11 = i0.ɵɵnextContext().$implicit;\n      const ctx_r22 = i0.ɵɵnextContext(2);\n      return ctx_r22.selectMatch(match_r11, $event);\n    });\n    i0.ɵɵtemplate(3, TypeaheadContainerComponent_ng_template_3_ng_template_2_li_1_ng_template_3_Template, 0, 0, \"ng-template\", 0);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r24 = i0.ɵɵnextContext();\n    const match_r11 = ctx_r24.$implicit;\n    const i_r12 = ctx_r24.index;\n    const ctx_r14 = i0.ɵɵnextContext(2);\n\n    const _r1 = i0.ɵɵreference(2);\n\n    i0.ɵɵclassProp(\"active\", ctx_r14.isActive(match_r11));\n    i0.ɵɵproperty(\"id\", ctx_r14.popupId + \"-\" + i_r12)(\"@typeaheadAnimation\", ctx_r14.animationState);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r14.itemTemplate || _r1)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction4(6, _c2, match_r11.item, i_r12, match_r11, ctx_r14.query));\n  }\n}\n\nfunction TypeaheadContainerComponent_ng_template_3_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, TypeaheadContainerComponent_ng_template_3_ng_template_2_li_0_Template, 3, 1, \"li\", 8);\n    i0.ɵɵtemplate(1, TypeaheadContainerComponent_ng_template_3_ng_template_2_li_1_Template, 4, 11, \"li\", 9);\n  }\n\n  if (rf & 2) {\n    const match_r11 = ctx.$implicit;\n    i0.ɵɵproperty(\"ngIf\", match_r11.isHeader());\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !match_r11.isHeader());\n  }\n}\n\nfunction TypeaheadContainerComponent_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"ul\", 5, 6);\n    i0.ɵɵtemplate(2, TypeaheadContainerComponent_ng_template_3_ng_template_2_Template, 2, 2, \"ng-template\", 7);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"overflow-y\", ctx_r4.needScrollbar ? \"scroll\" : \"auto\")(\"height\", ctx_r4.needScrollbar ? ctx_r4.guiHeight : \"auto\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r4.matches);\n  }\n}\n\nfunction TypeaheadContainerComponent_ng_template_5_ng_template_0_h6_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"h6\", 10);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const match_r26 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(match_r26);\n  }\n}\n\nfunction TypeaheadContainerComponent_ng_template_5_ng_template_0_ng_template_1_ng_template_2_Template(rf, ctx) {}\n\nfunction TypeaheadContainerComponent_ng_template_5_ng_template_0_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r35 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 15, 11);\n    i0.ɵɵlistener(\"click\", function TypeaheadContainerComponent_ng_template_5_ng_template_0_ng_template_1_Template_button_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r35);\n      const match_r26 = i0.ɵɵnextContext().$implicit;\n      const ctx_r33 = i0.ɵɵnextContext(2);\n      return ctx_r33.selectMatch(match_r26, $event);\n    })(\"mouseenter\", function TypeaheadContainerComponent_ng_template_5_ng_template_0_ng_template_1_Template_button_mouseenter_0_listener() {\n      i0.ɵɵrestoreView(_r35);\n      const match_r26 = i0.ɵɵnextContext().$implicit;\n      const ctx_r36 = i0.ɵɵnextContext(2);\n      return ctx_r36.selectActive(match_r26);\n    });\n    i0.ɵɵtemplate(2, TypeaheadContainerComponent_ng_template_5_ng_template_0_ng_template_1_ng_template_2_Template, 0, 0, \"ng-template\", 0);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r38 = i0.ɵɵnextContext();\n    const match_r26 = ctx_r38.$implicit;\n    const i_r27 = ctx_r38.index;\n    const ctx_r29 = i0.ɵɵnextContext(2);\n\n    const _r1 = i0.ɵɵreference(2);\n\n    i0.ɵɵclassProp(\"active\", ctx_r29.isActive(match_r26));\n    i0.ɵɵproperty(\"id\", ctx_r29.popupId + \"-\" + i_r27)(\"@typeaheadAnimation\", ctx_r29.animationState);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r29.itemTemplate || _r1)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction4(6, _c2, match_r26.item, i_r27, match_r26, ctx_r29.query));\n  }\n}\n\nfunction TypeaheadContainerComponent_ng_template_5_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, TypeaheadContainerComponent_ng_template_5_ng_template_0_h6_0_Template, 2, 1, \"h6\", 8);\n    i0.ɵɵtemplate(1, TypeaheadContainerComponent_ng_template_5_ng_template_0_ng_template_1_Template, 3, 11, \"ng-template\", 14);\n  }\n\n  if (rf & 2) {\n    const match_r26 = ctx.$implicit;\n    i0.ɵɵproperty(\"ngIf\", match_r26.isHeader());\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !match_r26.isHeader());\n  }\n}\n\nfunction TypeaheadContainerComponent_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, TypeaheadContainerComponent_ng_template_5_ng_template_0_Template, 2, 2, \"ng-template\", 7);\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngForOf\", ctx_r6.matches);\n  }\n}\n\nconst _c3 = function (a0, a1, a2, a3) {\n  return {\n    matches: a0,\n    itemTemplate: a1,\n    query: a2,\n    $implicit: a3\n  };\n};\n\nconst latinMap = {\n  'Á': 'A',\n  'Ă': 'A',\n  'Ắ': 'A',\n  'Ặ': 'A',\n  'Ằ': 'A',\n  'Ẳ': 'A',\n  'Ẵ': 'A',\n  'Ǎ': 'A',\n  'Â': 'A',\n  'Ấ': 'A',\n  'Ậ': 'A',\n  'Ầ': 'A',\n  'Ẩ': 'A',\n  'Ẫ': 'A',\n  'Ä': 'A',\n  'Ǟ': 'A',\n  'Ȧ': 'A',\n  'Ǡ': 'A',\n  'Ạ': 'A',\n  'Ȁ': 'A',\n  'À': 'A',\n  'Ả': 'A',\n  'Ȃ': 'A',\n  'Ā': 'A',\n  'Ą': 'A',\n  'Å': 'A',\n  'Ǻ': 'A',\n  'Ḁ': 'A',\n  'Ⱥ': 'A',\n  'Ã': 'A',\n  'Ꜳ': 'AA',\n  'Æ': 'AE',\n  'Ǽ': 'AE',\n  'Ǣ': 'AE',\n  'Ꜵ': 'AO',\n  'Ꜷ': 'AU',\n  'Ꜹ': 'AV',\n  'Ꜻ': 'AV',\n  'Ꜽ': 'AY',\n  'Ḃ': 'B',\n  'Ḅ': 'B',\n  'Ɓ': 'B',\n  'Ḇ': 'B',\n  'Ƀ': 'B',\n  'Ƃ': 'B',\n  'Ć': 'C',\n  'Č': 'C',\n  'Ç': 'C',\n  'Ḉ': 'C',\n  'Ĉ': 'C',\n  'Ċ': 'C',\n  'Ƈ': 'C',\n  'Ȼ': 'C',\n  'Ď': 'D',\n  'Ḑ': 'D',\n  'Ḓ': 'D',\n  'Ḋ': 'D',\n  'Ḍ': 'D',\n  'Ɗ': 'D',\n  'Ḏ': 'D',\n  'ǲ': 'D',\n  'ǅ': 'D',\n  'Đ': 'D',\n  'Ƌ': 'D',\n  'Ǳ': 'DZ',\n  'Ǆ': 'DZ',\n  'É': 'E',\n  'Ĕ': 'E',\n  'Ě': 'E',\n  'Ȩ': 'E',\n  'Ḝ': 'E',\n  'Ê': 'E',\n  'Ế': 'E',\n  'Ệ': 'E',\n  'Ề': 'E',\n  'Ể': 'E',\n  'Ễ': 'E',\n  'Ḙ': 'E',\n  'Ë': 'E',\n  'Ė': 'E',\n  'Ẹ': 'E',\n  'Ȅ': 'E',\n  'È': 'E',\n  'Ẻ': 'E',\n  'Ȇ': 'E',\n  'Ē': 'E',\n  'Ḗ': 'E',\n  'Ḕ': 'E',\n  'Ę': 'E',\n  'Ɇ': 'E',\n  'Ẽ': 'E',\n  'Ḛ': 'E',\n  'Ꝫ': 'ET',\n  'Ḟ': 'F',\n  'Ƒ': 'F',\n  'Ǵ': 'G',\n  'Ğ': 'G',\n  'Ǧ': 'G',\n  'Ģ': 'G',\n  'Ĝ': 'G',\n  'Ġ': 'G',\n  'Ɠ': 'G',\n  'Ḡ': 'G',\n  'Ǥ': 'G',\n  'Ḫ': 'H',\n  'Ȟ': 'H',\n  'Ḩ': 'H',\n  'Ĥ': 'H',\n  'Ⱨ': 'H',\n  'Ḧ': 'H',\n  'Ḣ': 'H',\n  'Ḥ': 'H',\n  'Ħ': 'H',\n  'Í': 'I',\n  'Ĭ': 'I',\n  'Ǐ': 'I',\n  'Î': 'I',\n  'Ï': 'I',\n  'Ḯ': 'I',\n  'İ': 'I',\n  'Ị': 'I',\n  'Ȉ': 'I',\n  'Ì': 'I',\n  'Ỉ': 'I',\n  'Ȋ': 'I',\n  'Ī': 'I',\n  'Į': 'I',\n  'Ɨ': 'I',\n  'Ĩ': 'I',\n  'Ḭ': 'I',\n  'Ꝺ': 'D',\n  'Ꝼ': 'F',\n  'Ᵹ': 'G',\n  'Ꞃ': 'R',\n  'Ꞅ': 'S',\n  'Ꞇ': 'T',\n  'Ꝭ': 'IS',\n  'Ĵ': 'J',\n  'Ɉ': 'J',\n  'Ḱ': 'K',\n  'Ǩ': 'K',\n  'Ķ': 'K',\n  'Ⱪ': 'K',\n  'Ꝃ': 'K',\n  'Ḳ': 'K',\n  'Ƙ': 'K',\n  'Ḵ': 'K',\n  'Ꝁ': 'K',\n  'Ꝅ': 'K',\n  'Ĺ': 'L',\n  'Ƚ': 'L',\n  'Ľ': 'L',\n  'Ļ': 'L',\n  'Ḽ': 'L',\n  'Ḷ': 'L',\n  'Ḹ': 'L',\n  'Ⱡ': 'L',\n  'Ꝉ': 'L',\n  'Ḻ': 'L',\n  'Ŀ': 'L',\n  'Ɫ': 'L',\n  'ǈ': 'L',\n  'Ł': 'L',\n  'Ǉ': 'LJ',\n  'Ḿ': 'M',\n  'Ṁ': 'M',\n  'Ṃ': 'M',\n  'Ɱ': 'M',\n  'Ń': 'N',\n  'Ň': 'N',\n  'Ņ': 'N',\n  'Ṋ': 'N',\n  'Ṅ': 'N',\n  'Ṇ': 'N',\n  'Ǹ': 'N',\n  'Ɲ': 'N',\n  'Ṉ': 'N',\n  'Ƞ': 'N',\n  'ǋ': 'N',\n  'Ñ': 'N',\n  'Ǌ': 'NJ',\n  'Ó': 'O',\n  'Ŏ': 'O',\n  'Ǒ': 'O',\n  'Ô': 'O',\n  'Ố': 'O',\n  'Ộ': 'O',\n  'Ồ': 'O',\n  'Ổ': 'O',\n  'Ỗ': 'O',\n  'Ö': 'O',\n  'Ȫ': 'O',\n  'Ȯ': 'O',\n  'Ȱ': 'O',\n  'Ọ': 'O',\n  'Ő': 'O',\n  'Ȍ': 'O',\n  'Ò': 'O',\n  'Ỏ': 'O',\n  'Ơ': 'O',\n  'Ớ': 'O',\n  'Ợ': 'O',\n  'Ờ': 'O',\n  'Ở': 'O',\n  'Ỡ': 'O',\n  'Ȏ': 'O',\n  'Ꝋ': 'O',\n  'Ꝍ': 'O',\n  'Ō': 'O',\n  'Ṓ': 'O',\n  'Ṑ': 'O',\n  'Ɵ': 'O',\n  'Ǫ': 'O',\n  'Ǭ': 'O',\n  'Ø': 'O',\n  'Ǿ': 'O',\n  'Õ': 'O',\n  'Ṍ': 'O',\n  'Ṏ': 'O',\n  'Ȭ': 'O',\n  'Ƣ': 'OI',\n  'Ꝏ': 'OO',\n  'Ɛ': 'E',\n  'Ɔ': 'O',\n  'Ȣ': 'OU',\n  'Ṕ': 'P',\n  'Ṗ': 'P',\n  'Ꝓ': 'P',\n  'Ƥ': 'P',\n  'Ꝕ': 'P',\n  'Ᵽ': 'P',\n  'Ꝑ': 'P',\n  'Ꝙ': 'Q',\n  'Ꝗ': 'Q',\n  'Ŕ': 'R',\n  'Ř': 'R',\n  'Ŗ': 'R',\n  'Ṙ': 'R',\n  'Ṛ': 'R',\n  'Ṝ': 'R',\n  'Ȑ': 'R',\n  'Ȓ': 'R',\n  'Ṟ': 'R',\n  'Ɍ': 'R',\n  'Ɽ': 'R',\n  'Ꜿ': 'C',\n  'Ǝ': 'E',\n  'Ś': 'S',\n  'Ṥ': 'S',\n  'Š': 'S',\n  'Ṧ': 'S',\n  'Ş': 'S',\n  'Ŝ': 'S',\n  'Ș': 'S',\n  'Ṡ': 'S',\n  'Ṣ': 'S',\n  'Ṩ': 'S',\n  'Ť': 'T',\n  'Ţ': 'T',\n  'Ṱ': 'T',\n  'Ț': 'T',\n  'Ⱦ': 'T',\n  'Ṫ': 'T',\n  'Ṭ': 'T',\n  'Ƭ': 'T',\n  'Ṯ': 'T',\n  'Ʈ': 'T',\n  'Ŧ': 'T',\n  'Ɐ': 'A',\n  'Ꞁ': 'L',\n  'Ɯ': 'M',\n  'Ʌ': 'V',\n  'Ꜩ': 'TZ',\n  'Ú': 'U',\n  'Ŭ': 'U',\n  'Ǔ': 'U',\n  'Û': 'U',\n  'Ṷ': 'U',\n  'Ü': 'U',\n  'Ǘ': 'U',\n  'Ǚ': 'U',\n  'Ǜ': 'U',\n  'Ǖ': 'U',\n  'Ṳ': 'U',\n  'Ụ': 'U',\n  'Ű': 'U',\n  'Ȕ': 'U',\n  'Ù': 'U',\n  'Ủ': 'U',\n  'Ư': 'U',\n  'Ứ': 'U',\n  'Ự': 'U',\n  'Ừ': 'U',\n  'Ử': 'U',\n  'Ữ': 'U',\n  'Ȗ': 'U',\n  'Ū': 'U',\n  'Ṻ': 'U',\n  'Ų': 'U',\n  'Ů': 'U',\n  'Ũ': 'U',\n  'Ṹ': 'U',\n  'Ṵ': 'U',\n  'Ꝟ': 'V',\n  'Ṿ': 'V',\n  'Ʋ': 'V',\n  'Ṽ': 'V',\n  'Ꝡ': 'VY',\n  'Ẃ': 'W',\n  'Ŵ': 'W',\n  'Ẅ': 'W',\n  'Ẇ': 'W',\n  'Ẉ': 'W',\n  'Ẁ': 'W',\n  'Ⱳ': 'W',\n  'Ẍ': 'X',\n  'Ẋ': 'X',\n  'Ý': 'Y',\n  'Ŷ': 'Y',\n  'Ÿ': 'Y',\n  'Ẏ': 'Y',\n  'Ỵ': 'Y',\n  'Ỳ': 'Y',\n  'Ƴ': 'Y',\n  'Ỷ': 'Y',\n  'Ỿ': 'Y',\n  'Ȳ': 'Y',\n  'Ɏ': 'Y',\n  'Ỹ': 'Y',\n  'Ź': 'Z',\n  'Ž': 'Z',\n  'Ẑ': 'Z',\n  'Ⱬ': 'Z',\n  'Ż': 'Z',\n  'Ẓ': 'Z',\n  'Ȥ': 'Z',\n  'Ẕ': 'Z',\n  'Ƶ': 'Z',\n  'Ĳ': 'IJ',\n  'Œ': 'OE',\n  'ᴀ': 'A',\n  'ᴁ': 'AE',\n  'ʙ': 'B',\n  'ᴃ': 'B',\n  'ᴄ': 'C',\n  'ᴅ': 'D',\n  'ᴇ': 'E',\n  'ꜰ': 'F',\n  'ɢ': 'G',\n  'ʛ': 'G',\n  'ʜ': 'H',\n  'ɪ': 'I',\n  'ʁ': 'R',\n  'ᴊ': 'J',\n  'ᴋ': 'K',\n  'ʟ': 'L',\n  'ᴌ': 'L',\n  'ᴍ': 'M',\n  'ɴ': 'N',\n  'ᴏ': 'O',\n  'ɶ': 'OE',\n  'ᴐ': 'O',\n  'ᴕ': 'OU',\n  'ᴘ': 'P',\n  'ʀ': 'R',\n  'ᴎ': 'N',\n  'ᴙ': 'R',\n  'ꜱ': 'S',\n  'ᴛ': 'T',\n  'ⱻ': 'E',\n  'ᴚ': 'R',\n  'ᴜ': 'U',\n  'ᴠ': 'V',\n  'ᴡ': 'W',\n  'ʏ': 'Y',\n  'ᴢ': 'Z',\n  'á': 'a',\n  'ă': 'a',\n  'ắ': 'a',\n  'ặ': 'a',\n  'ằ': 'a',\n  'ẳ': 'a',\n  'ẵ': 'a',\n  'ǎ': 'a',\n  'â': 'a',\n  'ấ': 'a',\n  'ậ': 'a',\n  'ầ': 'a',\n  'ẩ': 'a',\n  'ẫ': 'a',\n  'ä': 'a',\n  'ǟ': 'a',\n  'ȧ': 'a',\n  'ǡ': 'a',\n  'ạ': 'a',\n  'ȁ': 'a',\n  'à': 'a',\n  'ả': 'a',\n  'ȃ': 'a',\n  'ā': 'a',\n  'ą': 'a',\n  'ᶏ': 'a',\n  'ẚ': 'a',\n  'å': 'a',\n  'ǻ': 'a',\n  'ḁ': 'a',\n  'ⱥ': 'a',\n  'ã': 'a',\n  'ꜳ': 'aa',\n  'æ': 'ae',\n  'ǽ': 'ae',\n  'ǣ': 'ae',\n  'ꜵ': 'ao',\n  'ꜷ': 'au',\n  'ꜹ': 'av',\n  'ꜻ': 'av',\n  'ꜽ': 'ay',\n  'ḃ': 'b',\n  'ḅ': 'b',\n  'ɓ': 'b',\n  'ḇ': 'b',\n  'ᵬ': 'b',\n  'ᶀ': 'b',\n  'ƀ': 'b',\n  'ƃ': 'b',\n  'ɵ': 'o',\n  'ć': 'c',\n  'č': 'c',\n  'ç': 'c',\n  'ḉ': 'c',\n  'ĉ': 'c',\n  'ɕ': 'c',\n  'ċ': 'c',\n  'ƈ': 'c',\n  'ȼ': 'c',\n  'ď': 'd',\n  'ḑ': 'd',\n  'ḓ': 'd',\n  'ȡ': 'd',\n  'ḋ': 'd',\n  'ḍ': 'd',\n  'ɗ': 'd',\n  'ᶑ': 'd',\n  'ḏ': 'd',\n  'ᵭ': 'd',\n  'ᶁ': 'd',\n  'đ': 'd',\n  'ɖ': 'd',\n  'ƌ': 'd',\n  'ı': 'i',\n  'ȷ': 'j',\n  'ɟ': 'j',\n  'ʄ': 'j',\n  'ǳ': 'dz',\n  'ǆ': 'dz',\n  'é': 'e',\n  'ĕ': 'e',\n  'ě': 'e',\n  'ȩ': 'e',\n  'ḝ': 'e',\n  'ê': 'e',\n  'ế': 'e',\n  'ệ': 'e',\n  'ề': 'e',\n  'ể': 'e',\n  'ễ': 'e',\n  'ḙ': 'e',\n  'ë': 'e',\n  'ė': 'e',\n  'ẹ': 'e',\n  'ȅ': 'e',\n  'è': 'e',\n  'ẻ': 'e',\n  'ȇ': 'e',\n  'ē': 'e',\n  'ḗ': 'e',\n  'ḕ': 'e',\n  'ⱸ': 'e',\n  'ę': 'e',\n  'ᶒ': 'e',\n  'ɇ': 'e',\n  'ẽ': 'e',\n  'ḛ': 'e',\n  'ꝫ': 'et',\n  'ḟ': 'f',\n  'ƒ': 'f',\n  'ᵮ': 'f',\n  'ᶂ': 'f',\n  'ǵ': 'g',\n  'ğ': 'g',\n  'ǧ': 'g',\n  'ģ': 'g',\n  'ĝ': 'g',\n  'ġ': 'g',\n  'ɠ': 'g',\n  'ḡ': 'g',\n  'ᶃ': 'g',\n  'ǥ': 'g',\n  'ḫ': 'h',\n  'ȟ': 'h',\n  'ḩ': 'h',\n  'ĥ': 'h',\n  'ⱨ': 'h',\n  'ḧ': 'h',\n  'ḣ': 'h',\n  'ḥ': 'h',\n  'ɦ': 'h',\n  'ẖ': 'h',\n  'ħ': 'h',\n  'ƕ': 'hv',\n  'í': 'i',\n  'ĭ': 'i',\n  'ǐ': 'i',\n  'î': 'i',\n  'ï': 'i',\n  'ḯ': 'i',\n  'ị': 'i',\n  'ȉ': 'i',\n  'ì': 'i',\n  'ỉ': 'i',\n  'ȋ': 'i',\n  'ī': 'i',\n  'į': 'i',\n  'ᶖ': 'i',\n  'ɨ': 'i',\n  'ĩ': 'i',\n  'ḭ': 'i',\n  'ꝺ': 'd',\n  'ꝼ': 'f',\n  'ᵹ': 'g',\n  'ꞃ': 'r',\n  'ꞅ': 's',\n  'ꞇ': 't',\n  'ꝭ': 'is',\n  'ǰ': 'j',\n  'ĵ': 'j',\n  'ʝ': 'j',\n  'ɉ': 'j',\n  'ḱ': 'k',\n  'ǩ': 'k',\n  'ķ': 'k',\n  'ⱪ': 'k',\n  'ꝃ': 'k',\n  'ḳ': 'k',\n  'ƙ': 'k',\n  'ḵ': 'k',\n  'ᶄ': 'k',\n  'ꝁ': 'k',\n  'ꝅ': 'k',\n  'ĺ': 'l',\n  'ƚ': 'l',\n  'ɬ': 'l',\n  'ľ': 'l',\n  'ļ': 'l',\n  'ḽ': 'l',\n  'ȴ': 'l',\n  'ḷ': 'l',\n  'ḹ': 'l',\n  'ⱡ': 'l',\n  'ꝉ': 'l',\n  'ḻ': 'l',\n  'ŀ': 'l',\n  'ɫ': 'l',\n  'ᶅ': 'l',\n  'ɭ': 'l',\n  'ł': 'l',\n  'ǉ': 'lj',\n  'ſ': 's',\n  'ẜ': 's',\n  'ẛ': 's',\n  'ẝ': 's',\n  'ḿ': 'm',\n  'ṁ': 'm',\n  'ṃ': 'm',\n  'ɱ': 'm',\n  'ᵯ': 'm',\n  'ᶆ': 'm',\n  'ń': 'n',\n  'ň': 'n',\n  'ņ': 'n',\n  'ṋ': 'n',\n  'ȵ': 'n',\n  'ṅ': 'n',\n  'ṇ': 'n',\n  'ǹ': 'n',\n  'ɲ': 'n',\n  'ṉ': 'n',\n  'ƞ': 'n',\n  'ᵰ': 'n',\n  'ᶇ': 'n',\n  'ɳ': 'n',\n  'ñ': 'n',\n  'ǌ': 'nj',\n  'ó': 'o',\n  'ŏ': 'o',\n  'ǒ': 'o',\n  'ô': 'o',\n  'ố': 'o',\n  'ộ': 'o',\n  'ồ': 'o',\n  'ổ': 'o',\n  'ỗ': 'o',\n  'ö': 'o',\n  'ȫ': 'o',\n  'ȯ': 'o',\n  'ȱ': 'o',\n  'ọ': 'o',\n  'ő': 'o',\n  'ȍ': 'o',\n  'ò': 'o',\n  'ỏ': 'o',\n  'ơ': 'o',\n  'ớ': 'o',\n  'ợ': 'o',\n  'ờ': 'o',\n  'ở': 'o',\n  'ỡ': 'o',\n  'ȏ': 'o',\n  'ꝋ': 'o',\n  'ꝍ': 'o',\n  'ⱺ': 'o',\n  'ō': 'o',\n  'ṓ': 'o',\n  'ṑ': 'o',\n  'ǫ': 'o',\n  'ǭ': 'o',\n  'ø': 'o',\n  'ǿ': 'o',\n  'õ': 'o',\n  'ṍ': 'o',\n  'ṏ': 'o',\n  'ȭ': 'o',\n  'ƣ': 'oi',\n  'ꝏ': 'oo',\n  'ɛ': 'e',\n  'ᶓ': 'e',\n  'ɔ': 'o',\n  'ᶗ': 'o',\n  'ȣ': 'ou',\n  'ṕ': 'p',\n  'ṗ': 'p',\n  'ꝓ': 'p',\n  'ƥ': 'p',\n  'ᵱ': 'p',\n  'ᶈ': 'p',\n  'ꝕ': 'p',\n  'ᵽ': 'p',\n  'ꝑ': 'p',\n  'ꝙ': 'q',\n  'ʠ': 'q',\n  'ɋ': 'q',\n  'ꝗ': 'q',\n  'ŕ': 'r',\n  'ř': 'r',\n  'ŗ': 'r',\n  'ṙ': 'r',\n  'ṛ': 'r',\n  'ṝ': 'r',\n  'ȑ': 'r',\n  'ɾ': 'r',\n  'ᵳ': 'r',\n  'ȓ': 'r',\n  'ṟ': 'r',\n  'ɼ': 'r',\n  'ᵲ': 'r',\n  'ᶉ': 'r',\n  'ɍ': 'r',\n  'ɽ': 'r',\n  'ↄ': 'c',\n  'ꜿ': 'c',\n  'ɘ': 'e',\n  'ɿ': 'r',\n  'ś': 's',\n  'ṥ': 's',\n  'š': 's',\n  'ṧ': 's',\n  'ş': 's',\n  'ŝ': 's',\n  'ș': 's',\n  'ṡ': 's',\n  'ṣ': 's',\n  'ṩ': 's',\n  'ʂ': 's',\n  'ᵴ': 's',\n  'ᶊ': 's',\n  'ȿ': 's',\n  'ɡ': 'g',\n  'ᴑ': 'o',\n  'ᴓ': 'o',\n  'ᴝ': 'u',\n  'ť': 't',\n  'ţ': 't',\n  'ṱ': 't',\n  'ț': 't',\n  'ȶ': 't',\n  'ẗ': 't',\n  'ⱦ': 't',\n  'ṫ': 't',\n  'ṭ': 't',\n  'ƭ': 't',\n  'ṯ': 't',\n  'ᵵ': 't',\n  'ƫ': 't',\n  'ʈ': 't',\n  'ŧ': 't',\n  'ᵺ': 'th',\n  'ɐ': 'a',\n  'ᴂ': 'ae',\n  'ǝ': 'e',\n  'ᵷ': 'g',\n  'ɥ': 'h',\n  'ʮ': 'h',\n  'ʯ': 'h',\n  'ᴉ': 'i',\n  'ʞ': 'k',\n  'ꞁ': 'l',\n  'ɯ': 'm',\n  'ɰ': 'm',\n  'ᴔ': 'oe',\n  'ɹ': 'r',\n  'ɻ': 'r',\n  'ɺ': 'r',\n  'ⱹ': 'r',\n  'ʇ': 't',\n  'ʌ': 'v',\n  'ʍ': 'w',\n  'ʎ': 'y',\n  'ꜩ': 'tz',\n  'ú': 'u',\n  'ŭ': 'u',\n  'ǔ': 'u',\n  'û': 'u',\n  'ṷ': 'u',\n  'ü': 'u',\n  'ǘ': 'u',\n  'ǚ': 'u',\n  'ǜ': 'u',\n  'ǖ': 'u',\n  'ṳ': 'u',\n  'ụ': 'u',\n  'ű': 'u',\n  'ȕ': 'u',\n  'ù': 'u',\n  'ủ': 'u',\n  'ư': 'u',\n  'ứ': 'u',\n  'ự': 'u',\n  'ừ': 'u',\n  'ử': 'u',\n  'ữ': 'u',\n  'ȗ': 'u',\n  'ū': 'u',\n  'ṻ': 'u',\n  'ų': 'u',\n  'ᶙ': 'u',\n  'ů': 'u',\n  'ũ': 'u',\n  'ṹ': 'u',\n  'ṵ': 'u',\n  'ᵫ': 'ue',\n  'ꝸ': 'um',\n  'ⱴ': 'v',\n  'ꝟ': 'v',\n  'ṿ': 'v',\n  'ʋ': 'v',\n  'ᶌ': 'v',\n  'ⱱ': 'v',\n  'ṽ': 'v',\n  'ꝡ': 'vy',\n  'ẃ': 'w',\n  'ŵ': 'w',\n  'ẅ': 'w',\n  'ẇ': 'w',\n  'ẉ': 'w',\n  'ẁ': 'w',\n  'ⱳ': 'w',\n  'ẘ': 'w',\n  'ẍ': 'x',\n  'ẋ': 'x',\n  'ᶍ': 'x',\n  'ý': 'y',\n  'ŷ': 'y',\n  'ÿ': 'y',\n  'ẏ': 'y',\n  'ỵ': 'y',\n  'ỳ': 'y',\n  'ƴ': 'y',\n  'ỷ': 'y',\n  'ỿ': 'y',\n  'ȳ': 'y',\n  'ẙ': 'y',\n  'ɏ': 'y',\n  'ỹ': 'y',\n  'ź': 'z',\n  'ž': 'z',\n  'ẑ': 'z',\n  'ʑ': 'z',\n  'ⱬ': 'z',\n  'ż': 'z',\n  'ẓ': 'z',\n  'ȥ': 'z',\n  'ẕ': 'z',\n  'ᵶ': 'z',\n  'ᶎ': 'z',\n  'ʐ': 'z',\n  'ƶ': 'z',\n  'ɀ': 'z',\n  'ﬀ': 'ff',\n  'ﬃ': 'ffi',\n  'ﬄ': 'ffl',\n  'ﬁ': 'fi',\n  'ﬂ': 'fl',\n  'ĳ': 'ij',\n  'œ': 'oe',\n  'ﬆ': 'st',\n  'ₐ': 'a',\n  'ₑ': 'e',\n  'ᵢ': 'i',\n  'ⱼ': 'j',\n  'ₒ': 'o',\n  'ᵣ': 'r',\n  'ᵤ': 'u',\n  'ᵥ': 'v',\n  'ₓ': 'x'\n};\n\nclass TypeaheadOptions {\n  constructor(options) {\n    this.placement = options.placement;\n    this.animation = options.animation;\n    this.typeaheadRef = options.typeaheadRef;\n  }\n\n}\n\nclass TypeaheadMatch {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(item, value = item, header = false) {\n    this.item = item;\n    this.value = value;\n    this.header = header;\n  }\n\n  isHeader() {\n    return this.header;\n  }\n\n  toString() {\n    return this.value;\n  }\n\n}\n\nfunction latinize(str) {\n  if (!str) {\n    return '';\n  }\n\n  return str.replace(/[^A-Za-z0-9[\\] ]/g, function (a) {\n    return latinMap[a] || a;\n  });\n}\n\nfunction escapeRegexp(queryToEscape) {\n  // Regex: capture the whole query string and replace it with the string\n  // that will be used to match the results, for example if the capture is\n  // 'a' the result will be \\a\n  return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n}\n\nfunction tokenize(str, wordRegexDelimiters = ' ', phraseRegexDelimiters = '', delimitersForMultipleSearch) {\n  let result = [];\n\n  if (!delimitersForMultipleSearch) {\n    result = tokenizeWordsAndPhrases(str, wordRegexDelimiters, phraseRegexDelimiters);\n  } else {\n    const multipleSearchRegexStr = `([${delimitersForMultipleSearch}]+)`;\n    const delimitedTokens = str.split(new RegExp(multipleSearchRegexStr, 'g'));\n    const lastToken = delimitedTokens[delimitedTokens.length - 1];\n\n    if (lastToken > '') {\n      if (wordRegexDelimiters && phraseRegexDelimiters) {\n        result = tokenizeWordsAndPhrases(lastToken, wordRegexDelimiters, phraseRegexDelimiters);\n      } else {\n        result.push(lastToken);\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction tokenizeWordsAndPhrases(str, wordRegexDelimiters, phraseRegexDelimiters) {\n  const result = [];\n  const regexStr = `(?:[${phraseRegexDelimiters}])([^${phraseRegexDelimiters}]+)` + `(?:[${phraseRegexDelimiters}])|([^${wordRegexDelimiters}]+)`;\n  const preTokenized = str.split(new RegExp(regexStr, 'g'));\n  const preTokenizedLength = preTokenized.length;\n  let token;\n  const replacePhraseDelimiters = new RegExp(`[${phraseRegexDelimiters}]+`, 'g');\n\n  for (let i = 0; i < preTokenizedLength; i += 1) {\n    token = preTokenized[i];\n\n    if (token && token.length && token !== wordRegexDelimiters) {\n      result.push(token.replace(replacePhraseDelimiters, ''));\n    }\n  }\n\n  return result;\n} // eslint-disable-next-line\n\n\nfunction getValueFromObject(object, option) {\n  if (!option || typeof object !== 'object') {\n    return object.toString();\n  }\n\n  if (option.endsWith('()')) {\n    const functionName = option.slice(0, option.length - 2);\n    return object[functionName]().toString();\n  }\n\n  const properties = option.replace(/\\[(\\w+)\\]/g, '.$1').replace(/^\\./, '');\n  const propertiesArray = properties.split('.');\n\n  for (const property of propertiesArray) {\n    if (property in object) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      object = object[property];\n    }\n  }\n\n  if (!object) {\n    return '';\n  }\n\n  return object.toString();\n}\n\nconst TYPEAHEAD_ANIMATION_TIMING = '220ms cubic-bezier(0, 0, 0.2, 1)';\nconst typeaheadAnimation = trigger('typeaheadAnimation', [state('animated-down', style({\n  height: '*',\n  overflow: 'hidden'\n})), transition('* => animated-down', [style({\n  height: 0,\n  overflow: 'hidden'\n}), animate(TYPEAHEAD_ANIMATION_TIMING)]), state('animated-up', style({\n  height: '*',\n  overflow: 'hidden'\n})), transition('* => animated-up', [style({\n  height: '*',\n  overflow: 'hidden'\n}), animate(TYPEAHEAD_ANIMATION_TIMING)]), transition('* => unanimated', animate('0s'))]);\nlet nextWindowId = 0;\nlet TypeaheadContainerComponent = /*#__PURE__*/(() => {\n  class TypeaheadContainerComponent {\n    constructor(positionService, renderer, element, changeDetectorRef) {\n      this.positionService = positionService;\n      this.renderer = renderer;\n      this.element = element;\n      this.changeDetectorRef = changeDetectorRef; // eslint-disable-next-line @angular-eslint/no-output-rename\n\n      this.activeChangeEvent = new EventEmitter();\n      this.isFocused = false;\n      this.positionServiceSubscription = new Subscription();\n      this.height = 0;\n      this.popupId = `ngb-typeahead-${nextWindowId++}`;\n      this._matches = [];\n      this.renderer.setAttribute(this.element.nativeElement, 'id', this.popupId);\n      this.positionServiceSubscription.add(this.positionService.event$?.subscribe(() => {\n        if (this.isAnimated) {\n          this.animationState = this.isTopPosition ? 'animated-up' : 'animated-down';\n          this.changeDetectorRef.detectChanges();\n          return;\n        }\n\n        this.animationState = 'unanimated';\n        this.changeDetectorRef.detectChanges();\n      }));\n    }\n\n    get isBs4() {\n      return !isBs3();\n    }\n\n    get typeaheadTemplateMethods() {\n      return {\n        selectMatch: this.selectMatch.bind(this),\n        selectActive: this.selectActive.bind(this),\n        isActive: this.isActive.bind(this)\n      };\n    }\n\n    get active() {\n      return this._active;\n    }\n\n    set active(active) {\n      this._active = active;\n      this.activeChanged();\n    }\n\n    get matches() {\n      return this._matches;\n    }\n\n    set matches(value) {\n      this.positionService.setOptions({\n        modifiers: {\n          flip: {\n            enabled: this.adaptivePosition\n          }\n        },\n        allowedPositions: ['top', 'bottom']\n      });\n      this._matches = value;\n      this.needScrollbar = this.typeaheadScrollable && this.typeaheadOptionsInScrollableView < this.matches.length;\n\n      if (this.typeaheadScrollable) {\n        setTimeout(() => {\n          this.setScrollableMode();\n        });\n      }\n\n      if (this.typeaheadIsFirstItemActive && this._matches.length > 0) {\n        this.setActive(this._matches[0]);\n\n        if (this._active?.isHeader()) {\n          this.nextActiveMatch();\n        }\n      }\n\n      if (this._active && !this.typeaheadIsFirstItemActive) {\n        const concurrency = this._matches.find(match => match.value === this._active?.value);\n\n        if (concurrency) {\n          this.selectActive(concurrency);\n          return;\n        }\n\n        this.active = void 0;\n      }\n    }\n\n    get isTopPosition() {\n      return this.element.nativeElement.classList.contains('top');\n    }\n\n    get optionsListTemplate() {\n      return this.parent ? this.parent.optionsListTemplate : undefined;\n    }\n\n    get isAnimated() {\n      return this.parent ? this.parent.isAnimated : false;\n    }\n\n    get adaptivePosition() {\n      return this.parent ? this.parent.adaptivePosition : false;\n    }\n\n    get typeaheadScrollable() {\n      return this.parent ? this.parent.typeaheadScrollable : false;\n    }\n\n    get typeaheadOptionsInScrollableView() {\n      return this.parent ? this.parent.typeaheadOptionsInScrollableView : 5;\n    }\n\n    get typeaheadIsFirstItemActive() {\n      return this.parent ? this.parent.typeaheadIsFirstItemActive : true;\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    get itemTemplate() {\n      return this.parent ? this.parent.typeaheadItemTemplate : undefined;\n    }\n\n    get canSelectItemsOnBlur() {\n      return !!this.parent?.selectItemOnBlur;\n    }\n\n    selectActiveMatch(isActiveItemChanged) {\n      if (this._active && this.parent?.typeaheadSelectFirstItem) {\n        this.selectMatch(this._active);\n      }\n\n      if (!this.parent?.typeaheadSelectFirstItem && isActiveItemChanged) {\n        this.selectMatch(this._active);\n      }\n    }\n\n    activeChanged() {\n      if (!this._active) {\n        return;\n      }\n\n      const index = this.matches.indexOf(this._active);\n      this.activeChangeEvent.emit(`${this.popupId}-${index}`);\n    }\n\n    prevActiveMatch() {\n      if (!this._active) {\n        return;\n      }\n\n      const index = this.matches.indexOf(this._active);\n      this.setActive(this.matches[index - 1 < 0 ? this.matches.length - 1 : index - 1]);\n\n      if (this._active.isHeader()) {\n        this.prevActiveMatch();\n      }\n\n      if (this.typeaheadScrollable) {\n        this.scrollPrevious(index);\n      }\n    }\n\n    nextActiveMatch() {\n      const index = this._active ? this.matches.indexOf(this._active) : -1;\n      this.setActive(this.matches[index + 1 > this.matches.length - 1 ? 0 : index + 1]);\n\n      if (this._active?.isHeader()) {\n        this.nextActiveMatch();\n      }\n\n      if (this.typeaheadScrollable) {\n        this.scrollNext(index);\n      }\n    }\n\n    selectActive(value) {\n      this.isFocused = true;\n      this.setActive(value);\n    }\n\n    highlight(match, query) {\n      let itemStr = match.value;\n      let itemStrHelper = (this.parent && this.parent.typeaheadLatinize ? latinize(itemStr) : itemStr).toLowerCase();\n      let startIdx;\n      let tokenLen; // Replaces the capture string with the same string inside of a \"strong\" tag\n\n      if (typeof query === 'object') {\n        const queryLen = query.length;\n\n        for (let i = 0; i < queryLen; i += 1) {\n          // query[i] is already latinized and lower case\n          startIdx = itemStrHelper.indexOf(query[i]);\n          tokenLen = query[i].length;\n\n          if (startIdx >= 0 && tokenLen > 0) {\n            itemStr = `${itemStr.substring(0, startIdx)}<strong>${itemStr.substring(startIdx, startIdx + tokenLen)}</strong>` + `${itemStr.substring(startIdx + tokenLen)}`;\n            itemStrHelper = `${itemStrHelper.substring(0, startIdx)}        ${' '.repeat(tokenLen)}         ` + `${itemStrHelper.substring(startIdx + tokenLen)}`;\n          }\n        }\n      } else if (query) {\n        // query is already latinized and lower case\n        startIdx = itemStrHelper.indexOf(query);\n        tokenLen = query.length;\n\n        if (startIdx >= 0 && tokenLen > 0) {\n          itemStr = `${itemStr.substring(0, startIdx)}<strong>${itemStr.substring(startIdx, startIdx + tokenLen)}</strong>` + `${itemStr.substring(startIdx + tokenLen)}`;\n        }\n      }\n\n      return itemStr;\n    }\n\n    focusLost() {\n      this.isFocused = false;\n\n      if (!this.canSelectItemsOnBlur) {\n        this.setActive(void 0);\n      }\n    }\n\n    isActive(value) {\n      return this.active === value;\n    }\n\n    selectMatch(value, event) {\n      if (event) {\n        event.stopPropagation();\n        event.preventDefault();\n      }\n\n      this.parent?.changeModel(value);\n      setTimeout(() => this.parent?.typeaheadOnSelect.emit(value), 0);\n      return false;\n    }\n\n    setScrollableMode() {\n      if (!this.ulElement) {\n        this.ulElement = this.element;\n      }\n\n      if (this.liElements?.first) {\n        const ulStyles = Utils.getStyles(this.ulElement.nativeElement);\n        const liStyles = Utils.getStyles(this.liElements.first.nativeElement);\n        const ulPaddingBottom = parseFloat((ulStyles['padding-bottom'] ? ulStyles['padding-bottom'] : '').replace('px', ''));\n        const ulPaddingTop = parseFloat((ulStyles['padding-top'] ? ulStyles['padding-top'] : '0').replace('px', ''));\n        const optionHeight = parseFloat((liStyles.height ? liStyles.height : '0').replace('px', ''));\n        const height = this.typeaheadOptionsInScrollableView * optionHeight;\n        this.guiHeight = `${height + ulPaddingTop + ulPaddingBottom}px`;\n      }\n\n      this.renderer.setStyle(this.element.nativeElement, 'visibility', 'visible');\n    }\n\n    scrollPrevious(index) {\n      if (index === 0) {\n        this.scrollToBottom();\n        return;\n      }\n\n      if (this.liElements && this.ulElement) {\n        const liElement = this.liElements.toArray()[index - 1];\n\n        if (liElement && !this.isScrolledIntoView(liElement.nativeElement)) {\n          this.ulElement.nativeElement.scrollTop = liElement.nativeElement.offsetTop;\n        }\n      }\n    }\n\n    scrollNext(index) {\n      if (index + 1 > this.matches.length - 1) {\n        this.scrollToTop();\n        return;\n      }\n\n      if (this.liElements && this.ulElement) {\n        const liElement = this.liElements.toArray()[index + 1];\n\n        if (liElement && !this.isScrolledIntoView(liElement.nativeElement)) {\n          this.ulElement.nativeElement.scrollTop = liElement.nativeElement.offsetTop - Number(this.ulElement.nativeElement.offsetHeight) + Number(liElement.nativeElement.offsetHeight);\n        }\n      }\n    }\n\n    ngOnDestroy() {\n      this.positionServiceSubscription.unsubscribe();\n    }\n\n    setActive(value) {\n      this._active = value;\n      let preview;\n\n      if (!(this._active == null || this._active.isHeader())) {\n        preview = value;\n      }\n\n      this.parent?.typeaheadOnPreview.emit(preview);\n    }\n\n    isScrolledIntoView(elem) {\n      if (!this.ulElement) {\n        return false;\n      }\n\n      const containerViewTop = this.ulElement.nativeElement.scrollTop;\n      const containerViewBottom = containerViewTop + Number(this.ulElement.nativeElement.offsetHeight);\n      const elemTop = elem.offsetTop;\n      const elemBottom = elemTop + elem.offsetHeight;\n      return elemBottom <= containerViewBottom && elemTop >= containerViewTop;\n    }\n\n    scrollToBottom() {\n      if (!this.ulElement?.nativeElement) {\n        return;\n      }\n\n      this.ulElement.nativeElement.scrollTop = this.ulElement.nativeElement.scrollHeight;\n    }\n\n    scrollToTop() {\n      if (!this.ulElement?.nativeElement) {\n        return;\n      }\n\n      this.ulElement.nativeElement.scrollTop = 0;\n    }\n\n  }\n\n  TypeaheadContainerComponent.ɵfac = function TypeaheadContainerComponent_Factory(t) {\n    return new (t || TypeaheadContainerComponent)(i0.ɵɵdirectiveInject(i1.PositioningService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  TypeaheadContainerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TypeaheadContainerComponent,\n    selectors: [[\"typeahead-container\"]],\n    viewQuery: function TypeaheadContainerComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n        i0.ɵɵviewQuery(_c1, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.ulElement = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.liElements = _t);\n      }\n    },\n    hostAttrs: [1, \"dropdown\", \"open\", \"bottom\", 2, \"position\", \"absolute\", \"display\", \"block\"],\n    hostVars: 9,\n    hostBindings: function TypeaheadContainerComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"mouseleave\", function TypeaheadContainerComponent_mouseleave_HostBindingHandler() {\n          return ctx.focusLost();\n        })(\"blur\", function TypeaheadContainerComponent_blur_HostBindingHandler() {\n          return ctx.focusLost();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.isBs4 ? \"listbox\" : null);\n        i0.ɵɵstyleProp(\"height\", ctx.isBs4 && ctx.needScrollbar ? ctx.guiHeight : \"auto\")(\"visibility\", \"inherit\");\n        i0.ɵɵclassProp(\"dropdown-menu\", ctx.isBs4)(\"dropup\", ctx.dropup);\n      }\n    },\n    outputs: {\n      activeChangeEvent: \"activeChange\"\n    },\n    decls: 7,\n    vars: 7,\n    consts: [[3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"bsItemTemplate\", \"\"], [\"bs3Template\", \"\"], [\"bs4Template\", \"\"], [3, \"innerHtml\"], [\"role\", \"listbox\", 1, \"dropdown-menu\"], [\"ulElement\", \"\"], [\"ngFor\", \"\", 3, \"ngForOf\"], [\"class\", \"dropdown-header\", 4, \"ngIf\"], [\"role\", \"option\", 3, \"id\", \"active\", \"mouseenter\", 4, \"ngIf\"], [1, \"dropdown-header\"], [\"liElements\", \"\"], [\"role\", \"option\", 3, \"id\", \"mouseenter\"], [\"href\", \"#\", \"tabindex\", \"-1\", 3, \"click\"], [3, \"ngIf\"], [\"role\", \"option\", 1, \"dropdown-item\", 3, \"id\", \"click\", \"mouseenter\"]],\n    template: function TypeaheadContainerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, TypeaheadContainerComponent_ng_template_0_Template, 0, 0, \"ng-template\", 0);\n        i0.ɵɵtemplate(1, TypeaheadContainerComponent_ng_template_1_Template, 1, 1, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(3, TypeaheadContainerComponent_ng_template_3_Template, 3, 5, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(5, TypeaheadContainerComponent_ng_template_5_Template, 1, 1, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        const _r1 = i0.ɵɵreference(2);\n\n        const _r3 = i0.ɵɵreference(4);\n\n        const _r5 = i0.ɵɵreference(6);\n\n        i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.optionsListTemplate || (ctx.isBs4 ? _r5 : _r3))(\"ngTemplateOutletContext\", i0.ɵɵpureFunction4(2, _c3, ctx.matches, ctx.itemTemplate || _r1, ctx.query, ctx.typeaheadTemplateMethods));\n      }\n    },\n    directives: [i2.NgTemplateOutlet, i2.NgForOf, i2.NgIf],\n    styles: [\".dropdown[_nghost-%COMP%]{z-index:1000}.dropdown-menu[_nghost-%COMP%], .dropdown-menu[_ngcontent-%COMP%]{overflow-y:auto;height:100px}\"],\n    data: {\n      animation: [typeaheadAnimation]\n    }\n  });\n  return TypeaheadContainerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** Default values provider for typeahead */\n\n\nlet TypeaheadConfig = /*#__PURE__*/(() => {\n  class TypeaheadConfig {\n    constructor() {\n      /** sets use adaptive position */\n      this.adaptivePosition = false;\n      /** turn on/off animation */\n\n      this.isAnimated = false;\n      /** used to hide results on blur */\n\n      this.hideResultsOnBlur = true;\n      /** if true, typeahead will cancel async request on blur */\n\n      this.cancelRequestOnFocusLost = false;\n      /** used to choose the first item in typeahead container */\n\n      this.selectFirstItem = true;\n      /** used to active/inactive the first item in typeahead container */\n\n      this.isFirstItemActive = true;\n      /** used to choose set minimal no of characters that needs to\n       * be entered before typeahead kicks-in\n       */\n\n      this.minLength = 1;\n      /**\n       * used to choose item on blur event\n       */\n\n      this.selectItemOnBlur = false;\n    }\n\n  }\n\n  TypeaheadConfig.ɵfac = function TypeaheadConfig_Factory(t) {\n    return new (t || TypeaheadConfig)();\n  };\n\n  TypeaheadConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TypeaheadConfig,\n    factory: TypeaheadConfig.ɵfac,\n    providedIn: 'root'\n  });\n  return TypeaheadConfig;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TypeaheadDirective = /*#__PURE__*/(() => {\n  class TypeaheadDirective {\n    constructor(cis, config, changeDetection, element, ngControl, renderer, viewContainerRef) {\n      this.changeDetection = changeDetection;\n      this.element = element;\n      this.ngControl = ngControl;\n      this.renderer = renderer;\n      /** minimal no of characters that needs to be entered before\n       * typeahead kicks-in. When set to 0, typeahead shows on focus with full\n       * list of options (limited as normal by typeaheadOptionsLimit)\n       */\n\n      this.typeaheadMinLength = 1;\n      /** sets use adaptive position */\n\n      this.adaptivePosition = false;\n      /** turn on/off animation */\n\n      this.isAnimated = false;\n      /** minimal wait time after last character typed before typeahead kicks-in */\n\n      this.typeaheadWaitMs = 0;\n      /** match latin symbols.\n       * If true the word súper would match super and vice versa.\n       */\n\n      this.typeaheadLatinize = true;\n      /** Can be use to search words by inserting a single white space between each characters\n       *  for example 'C a l i f o r n i a' will match 'California'.\n       */\n\n      this.typeaheadSingleWords = true;\n      /** should be used only in case typeaheadSingleWords attribute is true.\n       * Sets the word delimiter to break words. Defaults to space.\n       */\n\n      this.typeaheadWordDelimiters = ' ';\n      /** should be used only in case typeaheadMultipleSearch attribute is true.\n       * Sets the multiple search delimiter to know when to start a new search. Defaults to comma.\n       * If space needs to be used, then explicitly set typeaheadWordDelimiters to something else than space\n       * because space is used by default OR set typeaheadSingleWords attribute to false if you don't need\n       * to use it together with multiple search.\n       */\n\n      this.typeaheadMultipleSearchDelimiters = ',';\n      /** should be used only in case typeaheadSingleWords attribute is true.\n       * Sets the word delimiter to match exact phrase.\n       * Defaults to simple and double quotes.\n       */\n\n      this.typeaheadPhraseDelimiters = '\\'\"';\n      /** specifies if typeahead is scrollable  */\n\n      this.typeaheadScrollable = false;\n      /** specifies number of options to show in scroll view  */\n\n      this.typeaheadOptionsInScrollableView = 5;\n      /** fired when an options list was opened and the user clicked Tab\n       * If a value equal true, it will be chosen first or active item in the list\n       * If value equal false, it will be chosen an active item in the list or nothing\n       */\n\n      this.typeaheadSelectFirstItem = true;\n      /** makes active first item in a list */\n\n      this.typeaheadIsFirstItemActive = true;\n      /** fired when 'busy' state of this component was changed,\n       * fired on async mode only, returns boolean\n       */\n\n      this.typeaheadLoading = new EventEmitter();\n      /** fired on every key event and returns true\n       * in case of matches are not detected\n       */\n\n      this.typeaheadNoResults = new EventEmitter();\n      /** fired when option was selected, return object with data of this option. */\n\n      this.typeaheadOnSelect = new EventEmitter();\n      /** fired when option was previewed, return object with data of this option. */\n\n      this.typeaheadOnPreview = new EventEmitter();\n      /** fired when blur event occurs. returns the active item */\n\n      this.typeaheadOnBlur = new EventEmitter();\n      /** This attribute indicates that the dropdown should be opened upwards */\n\n      this.dropup = false;\n      this.isOpen = false;\n      this.list = 'list';\n      this.isActiveItemChanged = false;\n      this.isFocused = false;\n      this.cancelRequestOnFocusLost = false;\n      this.selectItemOnBlur = false;\n      this.keyUpEventEmitter = new EventEmitter();\n      this.placement = 'bottom left';\n      this._matches = [];\n      this._subscriptions = [];\n\n      this._outsideClickListener = () => void 0;\n\n      this._typeahead = cis.createLoader(element, viewContainerRef, renderer).provide({\n        provide: TypeaheadConfig,\n        useValue: config\n      });\n      Object.assign(this, {\n        typeaheadHideResultsOnBlur: config.hideResultsOnBlur,\n        cancelRequestOnFocusLost: config.cancelRequestOnFocusLost,\n        typeaheadSelectFirstItem: config.selectFirstItem,\n        typeaheadIsFirstItemActive: config.isFirstItemActive,\n        typeaheadMinLength: config.minLength,\n        adaptivePosition: config.adaptivePosition,\n        isAnimated: config.isAnimated,\n        selectItemOnBlur: config.selectItemOnBlur\n      });\n    }\n\n    get matches() {\n      return this._matches;\n    }\n\n    ngOnInit() {\n      this.typeaheadOptionsLimit = this.typeaheadOptionsLimit || 20;\n      this.typeaheadMinLength = this.typeaheadMinLength === void 0 ? 1 : this.typeaheadMinLength; // async should be false in case of array\n\n      if (this.typeaheadAsync === undefined && !isObservable(this.typeahead)) {\n        this.typeaheadAsync = false;\n      }\n\n      if (isObservable(this.typeahead)) {\n        this.typeaheadAsync = true;\n      }\n\n      if (this.typeaheadAsync) {\n        this.asyncActions();\n      } else {\n        this.syncActions();\n      }\n\n      this.checkDelimitersConflict();\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    onInput(e) {\n      // For `<input>`s, use the `value` property. For others that don't have a\n      // `value` (such as `<span contenteditable=\"true\">`), use either\n      // `textContent` or `innerText` (depending on which one is supported, i.e.\n      // Firefox or IE).\n      const value = e.target.value !== undefined ? e.target.value : e.target.textContent !== undefined ? e.target.textContent : e.target.innerText;\n\n      if (value != null && value.trim().length >= this.typeaheadMinLength) {\n        this.typeaheadLoading.emit(true);\n        this.keyUpEventEmitter.emit(e.target.value);\n      } else {\n        this.typeaheadLoading.emit(false);\n        this.typeaheadNoResults.emit(false);\n        this.hide();\n      }\n    }\n\n    onChange(event) {\n      if (this._container) {\n        // esc\n        if (event.keyCode === 27 || event.key === 'Escape') {\n          this.hide();\n          return;\n        } // up\n\n\n        if (event.keyCode === 38 || event.key === 'ArrowUp') {\n          this.isActiveItemChanged = true;\n\n          this._container.prevActiveMatch();\n\n          return;\n        } // down\n\n\n        if (event.keyCode === 40 || event.key === 'ArrowDown') {\n          this.isActiveItemChanged = true;\n\n          this._container.nextActiveMatch();\n\n          return;\n        } // enter\n\n\n        if (event.keyCode === 13 || event.key === 'Enter') {\n          this._container.selectActiveMatch();\n\n          return;\n        }\n      }\n    }\n\n    onFocus() {\n      this.isFocused = true; // add setTimeout to fix issue #5251\n      // to get and emit updated value if it's changed on focus\n\n      setTimeout(() => {\n        if (this.typeaheadMinLength === 0) {\n          this.typeaheadLoading.emit(true);\n          this.keyUpEventEmitter.emit(this.element.nativeElement.value || '');\n        }\n      }, 0);\n    }\n\n    onBlur() {\n      this.isFocused = false;\n\n      if (this._container && !this._container.isFocused) {\n        this.typeaheadOnBlur.emit(this._container.active);\n      }\n\n      if (!this.container && this._matches?.length === 0) {\n        this.typeaheadOnBlur.emit(new TypeaheadMatch(this.element.nativeElement.value, this.element.nativeElement.value, false));\n      }\n    }\n\n    onKeydown(event) {\n      // no container - no problems\n      if (!this._container) {\n        return;\n      }\n\n      if (event.keyCode === 9 || event.key === 'Tab') {\n        this.onBlur();\n      }\n\n      if (event.keyCode === 9 || event.key === 'Tab' || event.keyCode === 13 || event.key === 'Enter') {\n        event.preventDefault();\n\n        if (this.typeaheadSelectFirstItem) {\n          this._container.selectActiveMatch();\n\n          return;\n        }\n\n        if (!this.typeaheadSelectFirstItem) {\n          this._container.selectActiveMatch(this.isActiveItemChanged);\n\n          this.isActiveItemChanged = false;\n          this.hide();\n        }\n      }\n    }\n\n    changeModel(match) {\n      if (!match) {\n        return;\n      }\n\n      let valueStr;\n\n      if (this.typeaheadMultipleSearch && this._allEnteredValue) {\n        const tokens = this._allEnteredValue.split(new RegExp(`([${this.typeaheadMultipleSearchDelimiters}]+)`));\n\n        this._allEnteredValue = tokens.slice(0, tokens.length - 1).concat(match.value).join('');\n        valueStr = this._allEnteredValue;\n      } else {\n        valueStr = match.value;\n      }\n\n      this.ngControl.viewToModelUpdate(valueStr);\n      this.ngControl.control?.setValue(valueStr);\n      this.changeDetection.markForCheck();\n      this.hide();\n    }\n\n    show() {\n      this._typeahead.attach(TypeaheadContainerComponent).to(this.container).position({\n        attachment: `${this.dropup ? 'top' : 'bottom'} left`\n      }).show({\n        typeaheadRef: this,\n        placement: this.placement,\n        animation: false,\n        dropup: this.dropup\n      });\n\n      this._outsideClickListener = this.renderer.listen('document', 'click', event => {\n        if (this.typeaheadMinLength === 0 && this.element.nativeElement.contains(event.target)) {\n          return;\n        }\n\n        if (!this.typeaheadHideResultsOnBlur || this.element.nativeElement.contains(event.target)) {\n          return;\n        }\n\n        this.onOutsideClick();\n      });\n\n      if (!this._typeahead.instance || !this.ngControl.control) {\n        return;\n      }\n\n      this._container = this._typeahead.instance;\n      this._container.parent = this; // This improves the speed as it won't have to be done for each list item\n\n      const normalizedQuery = (this.typeaheadLatinize ? latinize(this.ngControl.control.value) : this.ngControl.control.value).toString().toLowerCase();\n      this._container.query = this.tokenizeQuery(normalizedQuery);\n      this._container.matches = this._matches;\n      this.element.nativeElement.focus();\n\n      this._container.activeChangeEvent.subscribe(activeId => {\n        this.activeDescendant = activeId;\n        this.changeDetection.markForCheck();\n      });\n\n      this.isOpen = true;\n    }\n\n    hide() {\n      if (this._typeahead.isShown) {\n        this._typeahead.hide();\n\n        this._outsideClickListener();\n\n        this._container = void 0;\n        this.isOpen = false;\n        this.changeDetection.markForCheck();\n      }\n\n      this.typeaheadOnPreview.emit();\n    }\n\n    onOutsideClick() {\n      if (this._container && !this._container.isFocused) {\n        this.hide();\n      }\n    }\n\n    ngOnDestroy() {\n      // clean up subscriptions\n      for (const sub of this._subscriptions) {\n        sub.unsubscribe();\n      }\n\n      this._typeahead.dispose();\n    }\n\n    asyncActions() {\n      this._subscriptions.push(this.keyUpEventEmitter.pipe(debounceTime(this.typeaheadWaitMs), tap(value => this._allEnteredValue = value), switchMap(() => {\n        if (!this.typeahead) {\n          return EMPTY;\n        }\n\n        return this.typeahead;\n      })).subscribe(matches => {\n        this.finalizeAsyncCall(matches);\n      }));\n    }\n\n    syncActions() {\n      this._subscriptions.push(this.keyUpEventEmitter.pipe(debounceTime(this.typeaheadWaitMs), mergeMap(value => {\n        this._allEnteredValue = value;\n        const normalizedQuery = this.normalizeQuery(value);\n\n        if (!this.typeahead) {\n          return EMPTY;\n        }\n\n        const typeahead = isObservable(this.typeahead) ? this.typeahead : from(this.typeahead);\n        return typeahead.pipe(filter(option => {\n          return !!option && this.testMatch(this.normalizeOption(option), normalizedQuery);\n        }), toArray());\n      })).subscribe(matches => {\n        this.finalizeAsyncCall(matches);\n      }));\n    }\n\n    normalizeOption(option) {\n      const optionValue = getValueFromObject(option, this.typeaheadOptionField);\n      const normalizedOption = this.typeaheadLatinize ? latinize(optionValue) : optionValue;\n      return normalizedOption.toLowerCase();\n    }\n\n    tokenizeQuery(currentQuery) {\n      let query = currentQuery;\n\n      if (this.typeaheadMultipleSearch && this.typeaheadSingleWords) {\n        if (!this.haveCommonCharacters(`${this.typeaheadPhraseDelimiters}${this.typeaheadWordDelimiters}`, this.typeaheadMultipleSearchDelimiters)) {\n          // single words and multiple search delimiters are different, can be used together\n          query = tokenize(query, this.typeaheadWordDelimiters, this.typeaheadPhraseDelimiters, this.typeaheadMultipleSearchDelimiters);\n        }\n      } else if (this.typeaheadSingleWords) {\n        query = tokenize(query, this.typeaheadWordDelimiters, this.typeaheadPhraseDelimiters);\n      } else {\n        // multiple searches\n        query = tokenize(query, void 0, void 0, this.typeaheadMultipleSearchDelimiters);\n      }\n\n      return query;\n    }\n\n    normalizeQuery(value) {\n      // If singleWords, break model here to not be doing extra work on each iteration\n      let normalizedQuery = (this.typeaheadLatinize ? latinize(value) : value).toString().toLowerCase();\n      normalizedQuery = this.tokenizeQuery(normalizedQuery);\n      return normalizedQuery;\n    }\n\n    testMatch(match, test) {\n      let spaceLength;\n\n      if (typeof test === 'object') {\n        spaceLength = test.length;\n\n        for (let i = 0; i < spaceLength; i += 1) {\n          if (test[i].length > 0 && match.indexOf(test[i]) < 0) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      return match.indexOf(test) >= 0;\n    }\n\n    finalizeAsyncCall(matches) {\n      this.prepareMatches(matches || []);\n      this.typeaheadLoading.emit(false);\n      this.typeaheadNoResults.emit(!this.hasMatches());\n\n      if (!this.hasMatches()) {\n        this.hide();\n        return;\n      }\n\n      if (!this.isFocused && this.cancelRequestOnFocusLost) {\n        return;\n      }\n\n      if (this._container && this.ngControl.control) {\n        // fix: remove usage of ngControl internals\n        const _controlValue = (this.typeaheadLatinize ? latinize(this.ngControl.control.value) : this.ngControl.control.value) || ''; // This improves the speed as it won't have to be done for each list item\n\n\n        const normalizedQuery = _controlValue.toString().toLowerCase();\n\n        this._container.query = this.tokenizeQuery(normalizedQuery);\n        this._container.matches = this._matches;\n      } else {\n        this.show();\n      }\n    }\n\n    prepareMatches(options) {\n      const limited = options.slice(0, this.typeaheadOptionsLimit);\n      const sorted = !this.typeaheadOrderBy ? limited : this.orderMatches(limited);\n\n      if (this.typeaheadGroupField) {\n        let matches = []; // extract all group names\n\n        const groups = sorted.map(option => getValueFromObject(option, this.typeaheadGroupField)).filter((v, i, a) => a.indexOf(v) === i);\n        groups.forEach(group => {\n          // add group header to array of matches\n          matches.push(new TypeaheadMatch(group, group, true)); // add each item of group to array of matches\n\n          matches = matches.concat(sorted.filter(option => getValueFromObject(option, this.typeaheadGroupField) === group).map(option => new TypeaheadMatch(option, getValueFromObject(option, this.typeaheadOptionField))));\n        });\n        this._matches = matches;\n      } else {\n        this._matches = sorted.map( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        option => new TypeaheadMatch(option, getValueFromObject(option, this.typeaheadOptionField)));\n      }\n    }\n\n    orderMatches(options) {\n      if (!options.length) {\n        return options;\n      }\n\n      if (this.typeaheadOrderBy !== null && this.typeaheadOrderBy !== undefined && typeof this.typeaheadOrderBy === 'object' && Object.keys(this.typeaheadOrderBy).length === 0) {\n        console.error('Field and direction properties for typeaheadOrderBy have to be set according to documentation!');\n        return options;\n      }\n\n      const {\n        field,\n        direction\n      } = this.typeaheadOrderBy || {};\n\n      if (!direction || !(direction === 'asc' || direction === 'desc')) {\n        console.error('typeaheadOrderBy direction has to equal \"asc\" or \"desc\". Please follow the documentation.');\n        return options;\n      }\n\n      if (typeof options[0] === 'string') {\n        return direction === 'asc' ? options.sort() : options.sort().reverse();\n      }\n\n      if (!field || typeof field !== 'string') {\n        console.error('typeaheadOrderBy field has to set according to the documentation.');\n        return options;\n      }\n\n      return options.sort((a, b) => {\n        const stringA = getValueFromObject(a, field);\n        const stringB = getValueFromObject(b, field);\n\n        if (stringA < stringB) {\n          return direction === 'asc' ? -1 : 1;\n        }\n\n        if (stringA > stringB) {\n          return direction === 'asc' ? 1 : -1;\n        }\n\n        return 0;\n      });\n    }\n\n    hasMatches() {\n      return this._matches.length > 0;\n    }\n\n    checkDelimitersConflict() {\n      if (this.typeaheadMultipleSearch && this.typeaheadSingleWords && this.haveCommonCharacters(`${this.typeaheadPhraseDelimiters}${this.typeaheadWordDelimiters}`, this.typeaheadMultipleSearchDelimiters)) {\n        throw new Error(`Delimiters used in typeaheadMultipleSearchDelimiters must be different\n          from delimiters used in typeaheadWordDelimiters (current value: ${this.typeaheadWordDelimiters}) and\n          typeaheadPhraseDelimiters (current value: ${this.typeaheadPhraseDelimiters}).\n          Please refer to the documentation`);\n      }\n    }\n\n    haveCommonCharacters(str1, str2) {\n      for (let i = 0; i < str1.length; i++) {\n        if (str1.charAt(i).indexOf(str2) > -1) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n  }\n\n  TypeaheadDirective.ɵfac = function TypeaheadDirective_Factory(t) {\n    return new (t || TypeaheadDirective)(i0.ɵɵdirectiveInject(i1$1.ComponentLoaderFactory), i0.ɵɵdirectiveInject(TypeaheadConfig), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i3.NgControl), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  };\n\n  TypeaheadDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TypeaheadDirective,\n    selectors: [[\"\", \"typeahead\", \"\"]],\n    hostVars: 4,\n    hostBindings: function TypeaheadDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"input\", function TypeaheadDirective_input_HostBindingHandler($event) {\n          return ctx.onInput($event);\n        })(\"keyup\", function TypeaheadDirective_keyup_HostBindingHandler($event) {\n          return ctx.onChange($event);\n        })(\"click\", function TypeaheadDirective_click_HostBindingHandler() {\n          return ctx.onFocus();\n        })(\"focus\", function TypeaheadDirective_focus_HostBindingHandler() {\n          return ctx.onFocus();\n        })(\"blur\", function TypeaheadDirective_blur_HostBindingHandler() {\n          return ctx.onBlur();\n        })(\"keydown\", function TypeaheadDirective_keydown_HostBindingHandler($event) {\n          return ctx.onKeydown($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-activedescendant\", ctx.activeDescendant)(\"aria-owns\", ctx.isOpen ? ctx._container.popupId : null)(\"aria-expanded\", ctx.isOpen)(\"aria-autocomplete\", ctx.list);\n      }\n    },\n    inputs: {\n      typeahead: \"typeahead\",\n      typeaheadMinLength: \"typeaheadMinLength\",\n      adaptivePosition: \"adaptivePosition\",\n      isAnimated: \"isAnimated\",\n      typeaheadWaitMs: \"typeaheadWaitMs\",\n      typeaheadOptionsLimit: \"typeaheadOptionsLimit\",\n      typeaheadOptionField: \"typeaheadOptionField\",\n      typeaheadGroupField: \"typeaheadGroupField\",\n      typeaheadOrderBy: \"typeaheadOrderBy\",\n      typeaheadAsync: \"typeaheadAsync\",\n      typeaheadLatinize: \"typeaheadLatinize\",\n      typeaheadSingleWords: \"typeaheadSingleWords\",\n      typeaheadWordDelimiters: \"typeaheadWordDelimiters\",\n      typeaheadMultipleSearch: \"typeaheadMultipleSearch\",\n      typeaheadMultipleSearchDelimiters: \"typeaheadMultipleSearchDelimiters\",\n      typeaheadPhraseDelimiters: \"typeaheadPhraseDelimiters\",\n      typeaheadItemTemplate: \"typeaheadItemTemplate\",\n      optionsListTemplate: \"optionsListTemplate\",\n      typeaheadScrollable: \"typeaheadScrollable\",\n      typeaheadOptionsInScrollableView: \"typeaheadOptionsInScrollableView\",\n      typeaheadHideResultsOnBlur: \"typeaheadHideResultsOnBlur\",\n      typeaheadSelectFirstItem: \"typeaheadSelectFirstItem\",\n      typeaheadIsFirstItemActive: \"typeaheadIsFirstItemActive\",\n      container: \"container\",\n      dropup: \"dropup\"\n    },\n    outputs: {\n      typeaheadLoading: \"typeaheadLoading\",\n      typeaheadNoResults: \"typeaheadNoResults\",\n      typeaheadOnSelect: \"typeaheadOnSelect\",\n      typeaheadOnPreview: \"typeaheadOnPreview\",\n      typeaheadOnBlur: \"typeaheadOnBlur\"\n    },\n    exportAs: [\"bs-typeahead\"]\n  });\n  return TypeaheadDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TypeaheadModule = /*#__PURE__*/(() => {\n  class TypeaheadModule {\n    static forRoot() {\n      return {\n        ngModule: TypeaheadModule,\n        providers: [ComponentLoaderFactory, PositioningService]\n      };\n    }\n\n  }\n\n  TypeaheadModule.ɵfac = function TypeaheadModule_Factory(t) {\n    return new (t || TypeaheadModule)();\n  };\n\n  TypeaheadModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TypeaheadModule\n  });\n  TypeaheadModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return TypeaheadModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { TypeaheadConfig, TypeaheadContainerComponent, TypeaheadDirective, TypeaheadMatch, TypeaheadModule, TypeaheadOptions, escapeRegexp, getValueFromObject, latinMap, latinize, tokenize }; //# sourceMappingURL=ngx-bootstrap-typeahead.mjs.map","map":null,"metadata":{},"sourceType":"module"}